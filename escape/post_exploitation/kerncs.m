//
//  kerncs.m
//  escape
//
//  Created by Xiao on 2023/11/22.
//

#import <Foundation/Foundation.h>
#import "krw.h"
#import "kpf.h"
#import "kerncs.h"
#import "kcall.h"

char *csflag_names[] = {
    "CS_VALID",
    "CS_ADHOC",
    "CS_GET_TASK_ALLOW",
    "CS_INSTALLER",

    "CS_FORCED_LV",
    "CS_INVALID_ALLOWED",
    "CS_EMPTY",
    "CS_EMPTY",

    "CS_HARD",
    "CS_KILL",
    "CS_CHECK_EXPIRATION",
    "CS_RESTRICT",

    "CS_ENFORCEMENT",
    "CS_REQUIRE_LV",
    "CS_ENTITLEMENTS_VALID",
    "CS_NVRAM_UNRESTRICTED",

    "CS_RUNTIME",
    "CS_LINKER_SIGNED",
    "CS_EMPTY",
    "CS_EMPTY",

    "CS_EXEC_SET_HARD",
    "CS_EXEC_SET_KILL",
    "CS_EXEC_SET_ENFORCEMENT",
    "CS_EXEC_INHERIT_SIP",
    
    "CS_KILLED",
    "CS_NO_UNTRUSTED_HELPERS",
    "CS_DYLD_PLATFORM",
    "CS_PLATFORM_BINARY",
    "CS_PLATFORM_PATH",
    
    "CS_DEBUGGED",
    "CS_SIGNED",
    "CS_DEV_CODE",
    "CS_DATAVAULT_RETRIEVAL",
};

uint32_t proc_get_csflag(uint64_t proc) {
    
    if (@available(iOS 16, *)) {
        uint64_t proc_ro = kread64_2(proc + off_proc_proc_ro);
        uint64_t p_csflags_with_p_idversion = kread64_2(proc_ro + 0x1c);
        return p_csflags_with_p_idversion & 0xFFFFFFFF;
    } else {
        uint64_t proc_ro = kread64(proc + off_proc_proc_ro);
        
        uint64_t p_csflags_with_p_idversion = kread64(proc_ro + 0x1c);
        return p_csflags_with_p_idversion & 0xFFFFFFFF;
    }
}

void pretty_print_csflag(uint32_t csflag) {
    char buf[0x100] = { 0 };
    NSLog(@"[*] csflag: 0x%x", csflag);
    for (int i = 0; i < 32; ++i) {
        if (csflag & (1 << i)) {
            sprintf(buf, "%s%s ", buf, csflag_names[i]);
        }
    }
    NSLog(@"[*] csflag: %s", buf);
}

void proc_updatecsflags(uint64_t proc, uint32_t csflags) {
    if (@available(iOS 16, *)) {
        kcall2(off_proc_updatecsflags, proc, csflags, 0, 0, 0, 0);
    } else {
        kcall(off_proc_updatecsflags, proc, csflags, 0, 0, 0, 0, 0);

    }
}
