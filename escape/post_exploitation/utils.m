#import <Foundation/Foundation.h>
#import "utils.h"
#import "IOKit/IOKitLib.h"
#import "objcLogger.h"
#import <sys/stat.h>
#import "post_exp.h"
#import <pthread.h>
#import "post_exp.h"
#import "jailbreakd.h"
#import "ipc.h"
#import "krw.h"
#import "offsets.h"
#import "kcall.h"
#import "kerncs.h"
#import "trustcache.h"


#import "../_shared/libs/NSData/NSData+GZip.h"
//#import "../libs/NSData/NSData+GZip.h"//"NSData+GZip.h"
#include "../_shared/libs/NSString/NSString+SHA256.h"

void extractGz(const char *from, const char *to) {
    NSData *gz = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@(from) ofType:@"gz"]];
    NSData *extracted = [gz gunzippedData];
    int fd = open(to, O_CREAT | O_WRONLY, 0755);
    write(fd, [extracted bytes], [extracted length]);
    close(fd);
}


extern char **environ;

static pid_t jailbreakd_pid = 0;

BOOL jbd_set_kernelinfo(pid_t jbd_pid);

void copy_tar(void) {
    NSString *tarBinary = [NSString stringWithFormat:@"%@%@",
                         NSBundle.mainBundle.bundlePath, @"/tar.gz"];

    NSString *tar_pathextractBinary = [NSString stringWithFormat:@"%@%@",
                         NSBundle.mainBundle.bundlePath, @"/tar"];

     extractGz(tarBinary.UTF8String, tar_pathextractBinary.UTF8String);
//     extractGz(tarBinary.UTF8String, "/private/var/jb/tar");
    chmod(tar_pathextractBinary.UTF8String, 0755);

}


int runCommandv(const char *cmd, int argc, const char * const* argv, void (^unrestrict)(pid_t))
{
    pid_t pid;
    posix_spawn_file_actions_t *actions = NULL;
    posix_spawn_file_actions_t actionsStruct;
    int out_pipe[2];
    bool valid_pipe = false;
    posix_spawnattr_t *attr = NULL;
    posix_spawnattr_t attrStruct;

    valid_pipe = pipe(out_pipe) == 0;
    if (valid_pipe && posix_spawn_file_actions_init(&actionsStruct) == 0) {
        actions = &actionsStruct;
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 1);
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 2);
        posix_spawn_file_actions_addclose(actions, out_pipe[0]);
        posix_spawn_file_actions_addclose(actions, out_pipe[1]);
    }

    if (unrestrict && posix_spawnattr_init(&attrStruct) == 0) {
        attr = &attrStruct;
        posix_spawnattr_setflags(attr, POSIX_SPAWN_START_SUSPENDED);
    }

    int rv = posix_spawn(&pid, cmd, actions, attr, (char *const *)argv, environ);

    if (unrestrict) {
        unrestrict(pid);
        kill(pid, SIGCONT);
    }

    if (valid_pipe) {
        close(out_pipe[1]);
    }

    if (rv == 0) {
        if (valid_pipe) {
            char buf[256];
            ssize_t len;
            while (1) {
                len = read(out_pipe[0], buf, sizeof(buf) - 1);
                if (len == 0) {
                    break;
                }
                else if (len == -1) {
                    perror("posix_spawn, read pipe\n");
                }
                buf[len] = 0;
                NSLog(@"%s\n", buf);
            }
        }
        if (waitpid(pid, &rv, 0) == -1) {
            NSLog(@"ERROR: Waitpid failed\n");
        } else {
            NSLog(@"%s(%d) completed with exit status %d\n", __FUNCTION__, pid, WEXITSTATUS(rv));
        }

    } else {
        NSLog(@"%s(%d): ERROR posix_spawn failed (%d): %s\n", __FUNCTION__, pid, rv, strerror(rv));
        rv <<= 8; // Put error into WEXITSTATUS
    }
    if (valid_pipe) {
        close(out_pipe[0]);
    }
    return rv;
}

int util_runCommand(const char *cmd, ...)
{
    va_list ap, ap2;
    int argc = 1;

    va_start(ap, cmd);
    va_copy(ap2, ap);

    while (va_arg(ap, const char *) != NULL) {
        argc++;
    }
    va_end(ap);

    const char *argv[argc+1];
    argv[0] = cmd;
    for (int i=1; i<argc; i++) {
        argv[i] = va_arg(ap2, const char *);
    }
    va_end(ap2);
    argv[argc] = NULL;

    int rv = runCommandv(cmd, argc, argv, NULL);
    return WEXITSTATUS(rv);
}

const char* get_boothash(void) {
    io_registry_entry_t registryEntry = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/chosen");
    if (registryEntry == IO_OBJECT_NULL) {
        return NULL;
    }
    CFDataRef bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, CFSTR("boot-manifest-hash"), kCFAllocatorDefault, kNilOptions);
    if(!bootManifestHash) {
        return NULL;
    }
    
    IOObjectRelease(registryEntry);
    
    CFIndex length = CFDataGetLength(bootManifestHash) * 2 + 1;
    char *manifestHash = (char*)calloc(length, sizeof(char));
    
    int i = 0;
    for (i = 0; i<(int)CFDataGetLength(bootManifestHash); i++) {
        sprintf(manifestHash+i*2, "%02X", CFDataGetBytePtr(bootManifestHash)[i]);
    }
    manifestHash[i*2] = 0;
    
    CFRelease(bootManifestHash);
    
    return manifestHash;
}

static char* find_fakeroot(void) {
    NSString *boothash = [NSString stringWithUTF8String:get_boothash()];
    if (!boothash) {
        return NULL;
    }
    
    NSString *ppPath = [NSString stringWithFormat:@"/private/preboot/%@", boothash];
    NSError *error = nil;
    NSArray<NSString *> *candidateURLs = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:ppPath error:&error];
    if (!error) {
        for (NSString *candidatePath in candidateURLs) {
            if ([candidatePath.lastPathComponent hasPrefix:@"jb-"]) {
                char *ret = malloc(1024);
                strcpy(ret, [NSString stringWithFormat:@"%@/%@", ppPath, candidatePath].UTF8String);
                
                return ret;
            }
        }
    }
    return NULL;
}

static const char* gen_fakeroot(void) {
    NSString *letters = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    NSMutableString *result = [NSMutableString stringWithCapacity:6];
    
    for (NSUInteger i = 0; i < 6; i++) {
        NSUInteger randomIndex = arc4random_uniform((uint32_t)[letters length]);
        unichar randomCharacter = [letters characterAtIndex:randomIndex];
        [result appendFormat:@"%C", randomCharacter];
    }
    
    NSString *boothash = [NSString stringWithUTF8String:get_boothash()];
    if (!boothash) {
        return NULL;
    }
    
    NSString *fakeroot = [NSString stringWithFormat:@"/private/preboot/%@/jb-%@", boothash, result];
    return fakeroot.UTF8String;
}

static void *jb_init_thread(void *arg) {
    NSString *launchctl = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/launchctl"];
    chmod(launchctl.UTF8String, 0755);
    util_runCommand(launchctl.UTF8String, "unload", "/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist", NULL);
    util_runCommand(launchctl.UTF8String, "load", "/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist", NULL);
    return NULL;
}

void untar(NSString *path, NSString *target_path) {
    //copy_tar();
//    NSString *tar_path = [NSString stringWithFormat:@"%@%@",
  //                       NSBundle.mainBundle.bundlePath, @"/tar.gz"];
    NSString *tar_path = [NSString stringWithFormat:@"%@%@",
                         NSBundle.mainBundle.bundlePath, @"/tar"];
    extractGz("tar", tar_path.UTF8String);

    util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf", path.UTF8String, "-C", target_path.UTF8String, NULL);
}

BOOL start_jbenv() {
    setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/var/jb/sbin:/var/jb/bin:/var/jb/usr/sbin:/var/jb/usr/bin", 1);
    setenv("TERM", "xterm-256color", 1);
    
    NSString *jbpath = @"/var/jb";
    
    LOG(@"[*] remount preboot");
    if (util_runCommand("/sbin/mount", "-u", "-w", "/private/preboot", NULL)) {
        LOG(@"[-] failed to remount");
        return NO;
    }
    
    NSError *jberror = nil;
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb"
                                               error:&jberror];
    if (jberror) {
        LOG_FMT(@"[-] failed to remove bootstrap: %@", jberror);
        jberror = nil;
    }

    NSString *boothash_path = [NSString stringWithFormat:@"%s%s", "/private/preboot/", get_boothash()];
    LOG_FMT(@"[*] boothash_path %s", boothash_path.UTF8String);
    
    struct stat pathstat;
    if (stat(boothash_path.UTF8String, &pathstat) != 0) {
        perror("failed");
        LOG_FMT(@"[-] stat failed: %s\n", boothash_path.UTF8String);
        return NO;
    }
    
    uid_t ownerid = pathstat.st_uid;
    gid_t groupid = pathstat.st_gid;
    if (ownerid != 0 || groupid != 0) {
        if (chown(boothash_path.UTF8String, 0, 0) != 0) {
            perror("failed");
            LOG_FMT(@"[-] chown failed %s\n", boothash_path.UTF8String);
            return NO;
        }
    }
    
    mode_t permission = pathstat.st_mode & S_IRWXU;
    if (permission != 0755) {
        if (chmod(boothash_path.UTF8String, 0755) != 0) {
            perror("failed");
            LOG_FMT(@"[-] chmod failed %s\n", boothash_path.UTF8String);
            return NO;
        }
    }
    
    NSError *error = nil;
    NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:jbpath error:&error];
    
    if (!error) {
        if ([attributes[NSFileType] isEqualToString:NSFileTypeSymbolicLink]) {
            [[NSFileManager defaultManager] removeItemAtPath:jbpath error:&error];
        } else if ([attributes[NSFileType] isEqualToString:NSFileTypeDirectory]) {
            // wtf
            [[NSFileManager defaultManager] removeItemAtPath:jbpath error:&error];
        }
    }
    const char *fakeroot_path = find_fakeroot();
    if (!fakeroot_path) fakeroot_path = gen_fakeroot();
    
    error = nil;
    [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithUTF8String:fakeroot_path]
                                    withIntermediateDirectories:YES attributes:nil error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to create fakeroot %@, path: %@", error, [NSString stringWithUTF8String:fakeroot_path]);
    }
    
    NSString *procursus_path = [NSString stringWithFormat:@"%s/%s", fakeroot_path, "procursus"];
    NSString *jbinstalled = [NSString stringWithFormat:@"%@/%s", procursus_path, ".xia0o0o0o_jb_installed"];
    BOOL has_jb_installed = [[NSFileManager defaultManager] fileExistsAtPath:jbinstalled];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:jbinstalled]) {
        LOG(@"[*] .xia0o0o0o0_jb_installed is not existed");
    }
    
    error = nil;
    if (![[NSFileManager defaultManager] fileExistsAtPath:procursus_path]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:procursus_path
                                        withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            LOG_FMT(@"[-] failed to create procursus path: %@", error);
            return NO;
        }
    }
    
    LOG_FMT(@"[*] procursus_path: %@", procursus_path);
    LOG_FMT(@"[*] jbinstalled: %@", jbinstalled);
    
    if (!has_jb_installed) {
        // try remove the jb directory if jb is not installed
        [[NSFileManager defaultManager] removeItemAtPath:procursus_path error:nil];
    }
    
    error = nil;
    if (![[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithFormat:@"%@/basebin", procursus_path]]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithFormat:@"%@/basebin", procursus_path]
                                        withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            LOG_FMT(@"[-] failed to create basebin path: %@", error);
            return NO;
        }
    }
    
    error = nil;
    [[NSFileManager defaultManager] createSymbolicLinkAtPath:jbpath
                                    withDestinationPath:procursus_path error:&error];
    if (error) {
       LOG_FMT(@"[-] failed to symlink path: %@", error);
    }
    
    NSString *tar_path = [NSString stringWithFormat:@"%@%@",
                                NSBundle.mainBundle.bundlePath, @"/tar"];
    extractGz("tar", tar_path.UTF8String);

    if (chmod(tar_path.UTF8String, 0777)) {
        LOG(@"[-] failed to chmod");
        return NO;
    }

    
    
    NSString *binpack_path = [NSString stringWithFormat:@"%@%s",
                                NSBundle.mainBundle.bundlePath,
                                "/iosbinpack.tar"];
    NSString *launchctl_path = [NSString stringWithFormat:@"%@%s",
                                NSBundle.mainBundle.bundlePath,
                                "/launchctl.tar"];
    NSString *binaries_path = [NSString stringWithFormat:@"%@%s",
                                NSBundle.mainBundle.bundlePath,
                                "/binaries.tar"];
    NSString *jb_trustcache_path = [NSString stringWithFormat:@"%@%s",
                                NSBundle.mainBundle.bundlePath,
                                "/jb.tc"];
    util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf",
                    binpack_path.UTF8String, "-C", NSBundle.mainBundle.bundlePath.UTF8String, NULL);
    util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf",
                    launchctl_path.UTF8String, "-C", NSBundle.mainBundle.bundlePath.UTF8String, NULL);
    util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf",
                    binaries_path.UTF8String, "-C", NSBundle.mainBundle.bundlePath.UTF8String, NULL);
    uint64_t tcsize;
    load_trustcache(jb_trustcache_path, &tcsize);
    
    if (!has_jb_installed) {
        LOG(@"[*] extracting bootstrap");
        NSString *bootstrap_path = [NSString stringWithFormat:@"%@%s",
                                    NSBundle.mainBundle.bundlePath,
                                    "/bootstrap-iphoneos-arm64.tar"];
        
        extractGz("bootstrap-iphoneos-arm64.tar", bootstrap_path.UTF8String);

        NSString *cp_path = [NSString stringWithFormat:@"%@%@",
                             NSBundle.mainBundle.bundlePath, @"iosbinpack64/bin/cp"];
        util_runCommand(tar_path.UTF8String, "--strip-components=3", "--preserve-permissions", "-xvf",
                        bootstrap_path.UTF8String, "-C", "/var/jb", NULL);
        
    }
    LOG(@"[+] finished extracting bootstrap");
    
    void set_pidcred_for_pid(pid_t pid, pid_t target_pid);
    set_pidcred_for_pid(getpid(), 1);
    
    set_pidcred_for_pid(getpid(), 0);
    if (!start_jbd()) {
        LOG(@"[-] failed to start jailbreakd");
        return NO;
    }
    LOG(@"[+] started jailbreakd");
    
    LOG(@"[*] loading trustcache");
    usleep(100);
    if (jbdRebuildTrustCache()) {
        LOG(@"[*] failed to rebuild trustcache");
        return NO;
    }
    LOG(@"[*] loaded trustcache");
    
    NSString *deb_path = [NSString stringWithFormat:@"%@%@",
                         NSBundle.mainBundle.bundlePath, @"/deb.tar"];
    untar(deb_path, @"/var/jb/basebin");
    
    set_pidcred_for_pid(getpid(), 1);
    if (!has_jb_installed) {
        LOG(@"[*] installing packages");
        setenv("NO_PASSWORD_PROMPT", "1", 1);
        util_runCommand("/var/jb/bin/sh", "-c", "/var/jb/prep_bootstrap.sh", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/newterm3.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/sileo.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/ellekit.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/libpng.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/libssl.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/libssl-dev.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/libxpwn.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/xpwn.deb", NULL);
        util_runCommand("/var/jb/usr/bin/dpkg", "-i", "/var/jb/basebin/deb/libkrw0-xia0o0o0o.deb", NULL);
        util_runCommand("/var/jb/usr/bin/uicache", "-p", "/var/jb/Applications/NewTerm.app", NULL);
    }
    
    jbdRebuildTrustCache();
    
    pretty_print_csflag(proc_get_csflag(proc_for_pid(1)));
    uint32_t csflags = proc_get_csflag(proc_for_pid(1));
    csflags = csflags | CS_DEBUGGED | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW;
    csflags &= ~(CS_RESTRICT | CS_HARD | CS_KILL);
    proc_updatecsflags(proc_for_pid(jailbreakd_pid), csflags);
    proc_updatecsflags(proc_for_pid(1), csflags);
    pretty_print_csflag(proc_get_csflag(proc_for_pid(jailbreakd_pid)));
    pretty_print_csflag(proc_get_csflag(proc_for_pid(1)));
    
    if (jbdInitEnvironment()) {
        LOG(@"[-] failed to init environment");
        return NO;
    }
    
    LOG(@"[*] inject to launchd");
    set_pidcred_for_pid(getpid(), 0);
    util_runCommand("/var/jb/basebin/opainject", "1", "/var/jb/basebin/launchdhook.dylib", NULL);

    set_pidcred_for_pid(getpid(), 1);
    util_runCommand("/var/jb/usr/bin/launchctl", "bootstrap", "system", "/var/jb/Library/LaunchDaemons", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "cfprefsd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "chronod", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "mediaserverd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "securityd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "runningboardd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "installd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "profiled", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "assertiond", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "quicklookd", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "InCallService", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "SharingViewService", NULL);
    util_runCommand("/var/jb/usr/bin/killall", "-9", "iconservicesagent", NULL);
    util_runCommand("/var/jb/usr/bin/uicache", "-a", NULL);
    
    util_runCommand("/var/jb/usr/bin/touch", jbinstalled.UTF8String, NULL);
    
    return YES;
}

BOOL start_jbd() {
    LOG(@"[*] starting jailbreakd");
    LOG(@"[*] installing basebin");
    NSError *error = nil;

    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/LaunchDaemons" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove LaunchDaemons: %@", error);
        error = nil;
    }
    mkdir("/var/jb/basebin/LaunchDaemons", 0755);
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove com.xia0o0o0o.jailbreakd.plist: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/com.xia0o0o0o.jailbreakd.plist", NSBundle.mainBundle.bundlePath] toPath:@"/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy com.xia0o0o0o.jailbreakd.plist: %@", error);
        error = nil;
        return NO;
    }
    chown("/var/jb/basebin/LaunchDaemons/com.xia0o0o0o.jailbreakd.plist", 0, 0);
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jailbreakd" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jailbreakd: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jailbreakd", NSBundle.mainBundle.bundlePath] toPath:@"/var/jb/basebin/jailbreakd" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jailbreakd: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jailbreakd", 0, 0)) {
        LOG(@"[-] failed to chown jailbreakd");
    }
    if (chmod("/var/jb/basebin/jailbreakd", 0755)) {
        LOG(@"[-] failed to chmod jailbreakd");
    }

    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jbinit"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jbinit: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jbinit", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/jbinit" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jbinit: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jbinit", 0, 0)) {
        LOG(@"[-] failed to chown jbinit");
    }
    if (chmod("/var/jb/basebin/jbinit", 0755)) {
        LOG(@"[-] failed to chmod jbinit");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/jbctl"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove jbctl: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/jbctl", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/jbctl" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy jbctl: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/jbctl", 0, 0)) {
        LOG(@"[-] failed to chown jbctl");
    }
    if (chmod("/var/jb/basebin/jbctl", 0755)) {
        LOG(@"[-] failed to chmod jbctl");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/launchdhook.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove launchdhook.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/launchdhook.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/launchdhook.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy launchdhook.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/launchdhook.dylib", 0, 0)) {
        LOG(@"[-] failed to chown launchdhook.dylib");
    }
    if (chmod("/var/jb/basebin/launchdhook.dylib", 0755)) {
        LOG(@"[-] failed to chmod launchdhook.dylib");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/systemhook.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove systemhook.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/systemhook.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/systemhook.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy systemhook.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/systemhook.dylib", 0, 0)) {
        LOG(@"[-] failed to chown systemhook.dylib");
    }
    if (chmod("/var/jb/basebin/systemhook.dylib", 0755)) {
        LOG(@"[-] failed to chmod systemhook.dylib");
    }
    
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/rootlesshooks.dylib"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove rootlesshooks.dylib: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/rootlesshooks.dylib", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/rootlesshooks.dylib" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy rootlesshooks.dylib: %@", error);
        error = nil;
        return NO;
    }
    if (chown("/var/jb/basebin/rootlesshooks.dylib", 0, 0)) {
        LOG(@"[-] failed to chown rootlesshooks.dylib");
    }
    if (chmod("/var/jb/basebin/rootlesshooks.dylib", 0755)) {
        LOG(@"[-] failed to chmod rootlesshooks.dylib");
    }

    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/opainject"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove opainject: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/opainject", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/opainject" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy opainject: %@", error);
        error = nil;
    }
    if (chown("/var/jb/basebin/opainject", 0, 0)) {
        LOG(@"[-] failed to chown opainject");
    }
    if (chmod("/var/jb/basebin/opainject", 0755)) {
        LOG(@"[-] failed to chmod opainject");
    }
    
    mkdir("/var/jb/basebin/fallback", 0755);
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/fallback/CydiaSubstrate.framework"
                                               error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to remove fallback: %@", error);
        error = nil;
    }
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/fallback/CydiaSubstrate.framework", NSBundle.mainBundle.bundlePath] toPath:@"/var/jb/basebin/fallback/CydiaSubstrate.framework" error:&error];
    if (error) {
        LOG_FMT(@"[-] failed to copy fallback: %@", error);
        error = nil;
        return NO;
    }
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb/basebin/ramdisk.dmg"
                                               error:&error];
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithFormat:@"%@/ramdisk.dmg", NSBundle.mainBundle.bundlePath]
                                            toPath:@"/var/jb/basebin/ramdisk.dmg" error:&error];
    
    chown("/var/jb/basebin/fallback", 0, 0);
    chmod("/var/jb/basebin/fallback", 0755);
    chown("/var/jb/basebin/fallback/CydiaSubstrate.framework", 0, 0);
    chmod("/var/jb/basebin/fallback/CydiaSubstrate.framework", 0755);
    chown("/var/jb/basebin/fallback/CydiaSubstrate.framework/CydiaSubstrate", 0, 0);
    chmod("/var/jb/basebin/fallback/CydiaSubstrate.framework/CydiaSubstrate", 0644);
    chown("/var/jb/basebin/ramdisk.dmg", 0, 0);
    chmod("/var/jb/basebin/ramdisk.dmg", 0644);

    set_pidcred_for_pid(getpid(), 0);
    pthread_t thread;
    if (pthread_create(&thread, NULL, jb_init_thread, NULL) != 0) {
        perror("pthread_create failed");
        return NO;
    }
    usleep(1000000);
    
    xpc_object_t message = xpc_dictionary_create_empty();
    xpc_dictionary_set_uint64(message, "id", JBD_MSG_PING);
    xpc_dictionary_set_uint64(message, "pid", (uint64_t)getpid());

    xpc_object_t reply = sendJBDMessage(message);
    if (!reply)
        return NO;
    uint64_t ret = xpc_dictionary_get_uint64(reply, "ret");
    uint64_t _id = xpc_dictionary_get_uint64(reply, "id");
    uint64_t jbd_pid = xpc_dictionary_get_uint64(reply, "jbdpid");
    uint64_t jbd_proc = proc_for_pid((uint32_t)jbd_pid);
    LOG_FMT(@"[+] jailbreakd pid: %d", jbd_pid);
    LOG_FMT(@"[+] pong 0x%llx, id=%lld", ret, _id);
    LOG_FMT(@"[+] jbd_proc 0x%llx", jbd_proc);
    jailbreakd_pid = jbd_pid;
    if (ret != 0x00c0ffee) {
        return NO;
    }
    
    if (!jbd_set_kernelinfo((pid_t)jbd_pid)) {
        LOG(@"[-] failed to set kernel info for jailbreakd");
        return NO;
    }

//    FILE *fp = fopen("/var/mobile/jailbreakd-xpc.log", "r");
//    if (fp) {
//        char buf[1024];
//        while (fgets(buf, sizeof(buf), fp)) {
//            printf("%s", buf);
//        }
//        fclose(fp);
//    }
    
    return YES;
}

BOOL jbd_set_kernelinfo(pid_t jbd_pid) {
    extern uint64_t get_kernel_slide(void);
    
    xpc_object_t message = xpc_dictionary_create_empty();
    xpc_dictionary_set_uint64(message, "id", 0x101);
    xpc_object_t reply = sendJBDMessage(message);
    if (!reply) {
        LOG(@"[-] failed to receive reply, id=0x101");
        return NO;
    }
    uint64_t _id = xpc_dictionary_get_uint64(reply, "id");
    uint64_t ret = xpc_dictionary_get_uint64(reply, "ret");
    if (_id != 0x101 || ret) {
        LOG(@"[-] failed to receive reply, id=0x101");
        return NO;
    }
    uint64_t jbd_userclient = xpc_dictionary_get_uint64(reply, "clientport");
    if (!jbd_userclient) {
        LOG(@"[-] failed to receive clientport, id=0x101");
        return NO;
    }
    uint64_t userclient_port = port_name_to_ipc_port_for_pid((mach_port_t)jbd_userclient, (pid_t)jbd_pid);
    uint64_t userclient_addr = kread64_2(userclient_port + off_ipc_port_ip_kobject);
    uint64_t userclient_vtable = kread64_2(userclient_addr);
    uint64_t pmap_image4_trust_caches = off_trustcache;

    LOG_FMT(@"[*] remote userclient port %p, addr %p, vtable %p", userclient_port, userclient_addr, userclient_vtable);
    
    NSLog(@"[*] remote userclient port %p, addr %p, vtable %p", userclient_port, userclient_addr, userclient_vtable);
    // setup krw primitive
    void setup_remote_client(io_connect_t conn, pid_t pid, uint64_t *vtb, uint64_t *cli);
    setup_remote_client((io_connect_t)jbd_userclient, (pid_t)jbd_pid, &userclient_vtable, &userclient_addr);
    usleep(10000);
    install_kernel_primitive(userclient_addr, userclient_vtable);
    LOG_FMT(@"[*] remote userclient port %p, addr %p, vtable %p", userclient_port, userclient_addr, userclient_vtable);
    usleep(10000);
    
    message = xpc_dictionary_create_empty();
    xpc_dictionary_set_uint64(message, "id", 0x102);
    xpc_dictionary_set_uint64(message, "kslide", (uint64_t)get_kernel_slide());
    xpc_dictionary_set_uint64(message, "kbase", 0xfffffff007004000);
    xpc_dictionary_set_uint64(message, "kproc", get_kernel_cred());
    xpc_dictionary_set_uint64(message, "fake_userclient", userclient_addr);
    xpc_dictionary_set_uint64(message, "fake_userclient_vtable", userclient_vtable);
    xpc_dictionary_set_uint64(message, "self_proc", proc_for_pid(jbd_pid));
    xpc_dictionary_set_uint64(message, "addr_proc_set_ucred", off_proc_set_ucred);
    xpc_dictionary_set_uint64(message, "pmap_image4_trust_caches", pmap_image4_trust_caches);
    xpc_dictionary_set_uint64(message, "off_container_init", off_container_init);
    xpc_dictionary_set_uint64(message, "kcall_gadget", kcall_gadget);
    xpc_dictionary_set_uint64(message, "kread_gadget", kread_gadget);
    xpc_dictionary_set_uint64(message, "kwrite_gadget", kwrite_gadget);
    xpc_dictionary_set_uint64(message, "proc_updatecsflags", off_proc_updatecsflags);

    reply = sendJBDMessage(message);
    if (!reply) {
        LOG(@"[-] failed to receive reply, id=0x102");
        return NO;
    }
    _id = xpc_dictionary_get_uint64(reply, "id");
    ret = xpc_dictionary_get_uint64(reply, "ret");
    if (_id != 0x102 || ret)
        return NO;
// #define REMOTE_DEBUG
#ifdef REMOTE_DEBUG
    uint64_t jbd_kmem = jbdKalloc(0x100);
    NSLog(@"jbd_kmem = 0x%llx", jbd_kmem);
    
    uint64_t jbd_read = jbdKread64(0xfffffff007004000+get_kernel_slide());
    NSLog(@"jbd_read = 0x%llx", jbd_read);
    uint64_t jbd_write = jbdKwrite64(jbd_kmem, 0x1122334455667788);
    NSLog(@"jbd_write = 0x%llx", jbd_write);
    
    uint64_t jbd_read2 = jbdKread64(jbd_kmem);
    NSLog(@"jbd_read = 0x%llx", jbd_read2);
#endif
    
    return YES;
}
