//
//  ipc.m
//  escape
//
//  Created by Xiao on 2023/11/15.
//

#import <Foundation/Foundation.h>
#import "objcLogger.h"
#import "offsets.h"
#import "libkfd.h"
#import "krw.h"
#import "post_exp.h"
#import "kcall.h"

extern uint64_t __kfd;

uint64_t ipc_entry_lookup(mach_port_t port_name) {
    struct kfd *kfd = (struct kfd *)__kfd;
    LOG_FMT(@"[*] enter %s lookup", __PRETTY_FUNCTION__);
    uint64_t task = kfd->info.kernel.current_task;
    uint64_t itk_space = kread64(task + off_task_itk_space);
    uint32_t port_index = MACH_PORT_INDEX(port_name);
    uint64_t is_table = kread64(itk_space + off_ipc_space_is_table);
    is_table = kernel_pointer_decode(is_table);
    uint64_t entry = is_table + port_index * 0x18;
    return entry;
}

uint64_t ipc_entry_lookup_for_pid(mach_port_t port_name, pid_t pid) {
    uint64_t task = taskptr_for_pid(pid);
    uint64_t itk_space = kread64_2(task + off_task_itk_space);
    uint32_t port_index = MACH_PORT_INDEX(port_name);
    uint64_t is_table = kernel_pointer_decode(kread64_2(itk_space + off_ipc_space_is_table));
    uint64_t entry = is_table + port_index * 0x18;
    return entry;
}

uint64_t port_name_to_ipc_port(mach_port_t port_name) {
    uint64_t entry = ipc_entry_lookup(port_name);
    uint64_t ipc_port = kread64(entry + 0x0);
    return ipc_port;
}

uint64_t port_name_to_ipc_port_for_pid(mach_port_t name, pid_t pid) {
    uint64_t entry = ipc_entry_lookup_for_pid(name, pid);
    return kread64(entry);
}

uint64_t port_name_to_kobject(mach_port_t port_name) {
    uint64_t ipc_port = port_name_to_ipc_port(port_name);
    uint64_t kobject = kread64(ipc_port + off_ipc_port_ip_kobject);
    return kobject;
}
