#import <Foundation/Foundation.h>
#import "trustcache.h"
#import "objcLogger.h"
#import "offsets.h"
#import "libkfd.h"
#import "krw.h"
#import "kcall.h"

BOOL insert_trustcache(uint64_t tcaddr) {
    uint64_t pmap_image4_trustcaches = off_trustcache;
    uint64_t trustcache = kread64_2(pmap_image4_trustcaches);
    LOG_FMT(@"[*] trustcache: 0x%llx", trustcache);
    if (!trustcache) {
        kwrite64_2(pmap_image4_trustcaches, tcaddr);
        return YES;
    }
    uint64_t prev = 0;
    while (trustcache) {
        prev = trustcache;
        trustcache = kread64_2(trustcache);
    }
    
    if (@available(iOS 16, *)) {
        kwrite64_2(prev, tcaddr);
        kwrite64_2(tcaddr+8, prev);
        return YES;
    }
    
    kwrite64_2(prev, tcaddr);
    return YES;
}

uint64_t load_trustcache(NSString *path, uint64_t *back_addr) {
    NSData *data = [NSData dataWithContentsOfFile:path];
    if (data == nil) {
        LOG(@"[-] Failed to load trustcache, no trustcache buffer provided");
        return 0;
    }

    trustcache_file *tc = (trustcache_file *)data.bytes;
    
    uint64_t alloc_size = sizeof(trustcache_page) + data.length + 0x8;
        
    if (@available(iOS 16, *)) {
        alloc_size = sizeof(trustcache_module) + data.length + 0x8;
    }
    
    uint64_t tcaddr = kmalloc_2(alloc_size);
    uint64_t payload = kmalloc_2(alloc_size);

    if (!tcaddr) {
        LOG(@"[-] Failed to allocate trustcache");
        return 0;
    }

    if (@available(iOS 16, *)) {
        for (int i = 0; i < data.length; ++i) {
            kwrite8_2(payload + i, ((uint8_t *)data.bytes)[i]);
        }
        kwrite64_2(tcaddr + offsetof(trustcache_module, fileptr), payload);
        kwrite64_2(tcaddr + offsetof(trustcache_module, module_size), data.length);
    } else {
        kwrite64_2(tcaddr + offsetof(trustcache_page, selfptr), tcaddr + offsetof(trustcache_page, file));

        for (int i = 0; i < data.length; ++i) {
            kwrite8_2(tcaddr + offsetof(trustcache_page, file) + i, ((uint8_t *)data.bytes)[i]);
        }
    }

    if (!insert_trustcache(tcaddr)) {
        return 0;
    }
    *back_addr = tcaddr;
    return alloc_size;
}
